[1mdiff --git a/esp/ESP12/aws_iot_mqtt_esp32/.gitignore b/esp/ESP12/aws_iot_mqtt_esp32/.gitignore[m
[1mindex 9667419..89cc49c 100644[m
[1m--- a/esp/ESP12/aws_iot_mqtt_esp32/.gitignore[m
[1m+++ b/esp/ESP12/aws_iot_mqtt_esp32/.gitignore[m
[36m@@ -3,4 +3,3 @@[m
 .vscode/c_cpp_properties.json[m
 .vscode/launch.json[m
 .vscode/ipch[m
[31m-secrets.h[m
[1mdiff --git a/esp/ESP12/aws_iot_mqtt_esp32/src/main.cpp b/esp/ESP12/aws_iot_mqtt_esp32/src/main.cpp[m
[1mindex dff1816..6893de9 100644[m
[1m--- a/esp/ESP12/aws_iot_mqtt_esp32/src/main.cpp[m
[1m+++ b/esp/ESP12/aws_iot_mqtt_esp32/src/main.cpp[m
[36m@@ -3,17 +3,20 @@[m
 #include <MQTTClient.h>[m
 #include <ArduinoJson.h>[m
 #include <WiFi.h>[m
[32m+[m[32m#include<time.h>[m
 [m
[32m+[m[32m#include "adxl357b_app.h"[m
 #include "secrets.h"[m
 [m
 //MQTT topics that this device will publish/subscribe[m
[31m-#define AWS_IOT_PUBLISH_TOPIC   "esp32_1/pub"[m
[31m-#define AWS_IOT_SUBSCRIBE_TOPIC "esp32_1/sub"[m
[32m+[m[32m#define AWS_IOT_PUBLISH_TOPIC   "esp32_1/samples"[m
[32m+[m[32m#define AWS_IOT_SUBSCRIBE_TOPIC "esp32_1/commands"[m
 [m
 [m
 void connectAWS();[m
 void messageHandler(String &topic, String &payload);[m
 void publishMessage();[m
[32m+[m[32mString getTime();[m
 [m
 [m
 [m
[36m@@ -21,6 +24,11 @@[m [mWiFiClientSecure network = WiFiClientSecure();[m
 MQTTClient client = MQTTClient(256);[m
 [m
 [m
[32m+[m[32mconst char* ntpServer = "pool.ntp.org";[m
[32m+[m[32mconst long  gmtOffset_sec = 3600;[m
[32m+[m[32mconst int   daylightOffset_sec = 3600;[m
[32m+[m
[32m+[m
 [m
 void connectAWS(){[m
   WiFi.mode(WIFI_STA);[m
[36m@@ -32,6 +40,10 @@[m [mvoid connectAWS(){[m
     delay(500);[m
     Serial.print(".");[m
   }[m
[32m+[m[32m  Serial.println("");[m
[32m+[m
[32m+[m[32m  // Init time connecting to ntpServer[m
[32m+[m[32m  configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);[m
 [m
   // Configure WiFiClientSecure to use the AWS IoT device credentials[m
   network.setCACert(AWS_CERT_CA);[m
[36m@@ -50,6 +62,7 @@[m [mvoid connectAWS(){[m
     Serial.print(".");[m
     delay(100);[m
   }[m
[32m+[m[32m  Serial.println("");[m
 [m
   if(!client.connected()){[m
     Serial.println("AWS IoT Timeout!");[m
[36m@@ -58,17 +71,27 @@[m [mvoid connectAWS(){[m
 [m
   //Subscribe to a topic[m
   client.subscribe(AWS_IOT_SUBSCRIBE_TOPIC);[m
[31m-  Serial.println("AWS IoT Connected!");[m
[32m+[m[32m  Serial.println("Connected AWS IoT!");[m
 }[m
 [m
 void messageHandler(String &topic, String &payload){[m
   Serial.println("incoming: " + topic + " - " + payload);[m
[32m+[m
[32m+[m[32m  StaticJsonDocument<200> doc;[m
[32m+[m[32m  deserializeJson(doc, payload);[m
[32m+[m
[32m+[m[32m  if(doc["command"] == "takeSample"){[m
[32m+[m[32m    Serial.println("Yes, master!");[m
[32m+[m[32m    takeSamples();[m
[32m+[m[32m  }[m
 }[m
 [m
 void publishMessage(){[m
   StaticJsonDocument<200> doc;[m
[31m-  doc["time"] = millis();[m
[31m-  doc["sensor_a0"] = analogRead(0);[m
[32m+[m[32m  doc["time"] = getTime();[m
[32m+[m[32m  doc["x"] = analogRead(0);[m
[32m+[m[32m  doc["y"] = analogRead(1);[m
[32m+[m[32m  doc["z"] = analogRead(2);[m
 [m
   char jsonBuffer[512];[m
   serializeJson(doc, jsonBuffer);[m
[36m@@ -77,13 +100,23 @@[m [mvoid publishMessage(){[m
 }[m
 [m
 [m
[32m+[m[32mString getTime(){[m
[32m+[m[32m  struct tm timeinfo;[m
[32m+[m[32m  if(!getLocalTime(&timeinfo)){[m
[32m+[m[32m    return "Failed to obtain time";[m
[32m+[m[32m  }[m
[32m+[m[32m  return asctime(&timeinfo);[m
[32m+[m[32m}[m
[32m+[m
[32m+[m
 void setup() {[m
   Serial.begin(115200);[m
   connectAWS();[m
[32m+[m[32m  startAccelerometer();[m
 }[m
 [m
 void loop() {[m
[31m-  publishMessage();[m
[32m+[m[32m  //publishMessage();[m
   client.loop();[m
[31m-  delay(10000);[m
[32m+[m[32m  delay(1000);[m
 }[m
\ No newline at end of file[m
